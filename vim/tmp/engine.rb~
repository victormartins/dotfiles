module AccountsEngine

  module DSL
    module Engine
      def self.included(base)
        base.class_eval do
          extend ClassMethods
          init_transaction_dsl
        end
      end

      module ClassMethods

        def define_transaction(name, options = {}, &block)

          @transaction_rules[@current_ruleset] ||= {}
          add_transaction_to_rule(name, options,  &block)
        end

        def redefine_transaction(name, options = {}, & block)

          @transaction_rules[@current_ruleset] ||= {}
          rule_type = options[:rule_type] if options[:rule_type].present?
          if current_rule_exists?(name, rule_type)
            add_current_ruleset(name, rule_type, & block)
          else
            raise Exceptions::Engine::NoRuleDefined, name
          end
        end

        def post_transaction(name, origin, params = {})
          ensure_subject_and_rule_present
          @transaction_rules[ruleset] ||= {}

          if origin.respond_to? :rule_type
            rule_type = origin.rule_type
          else
            rule_type = :default
          end

          block = get_current_rule(name, rule_type)
          world = TransactionWorld.new name

          #Setup world according to the rule being applied
          world.instance_exec origin, & block
          world.finalize
          #post
          world.post_entries name, origin
        end

        def ensure_subject_and_rule_present
          raise Exceptions::Engine::SubjectRequired.new("Define subject (ie. business), try with @business do...") unless AccountsEngine::Core.subject
          raise Exceptions::Engine::RulesetRequired.new("Define ruleset (ie. en), try with @business, :ruleset => 'en' do...") unless AccountsEngine::Core.ruleset
        end

        private

        def add_transaction_to_rule(name, options, & block)
          rule_type = options[:rule_type] if options[:rule_type].present?

          if current_rule_exists?(name, rule_type)
            raise Exceptions::Engine::RuleAlreadyDefined, name
          else
            add_current_ruleset(name, rule_type, & block)
          end
        end

        def add_current_ruleset(name, rule_type, & block)
          @transaction_rules[@current_ruleset][name] ||= {}
          if rule_type.present?
            @transaction_rules[@current_ruleset][name][rule_type] = block
          else
            @transaction_rules[@current_ruleset][name][:default] = block
          end
        end

        def current_rule_exists?(name, rule_type)
          return false unless @transaction_rules[@current_ruleset].has_key? name

          if rule_type.present?
             @transaction_rules[@current_ruleset][name].has_key? rule_type
          else
            @transaction_rules[@current_ruleset][name].has_key? :default
          end
        end

        def get_current_rule(name, rule_type)
          raise Exceptions::Engine::NoRuleDefined, name unless @transaction_rules[ruleset].has_key? name

          if @transaction_rules[ruleset][name].has_key? rule_type
            @transaction_rules[ruleset][name][rule_type]
          elsif @transaction_rules[ruleset][name].has_key? :default
            @transaction_rules[ruleset][name][:default]
          else
            raise Exceptions::Engine::NoRuleDefined, " #{name} #{rule_type}"
          end
        end

        def init_transaction_dsl
          @transaction_rules = {}
        end

        # def rule_name(name, options)
        #   options[:rule_type].present? ? "#{name}.#{options.delete(:rule_type)}".to_sym : "#{name}".to_sym
        # end
      end

      class TransactionWorld

        def initialize(rule_name)
          @rule_name = rule_name
          @cur_from_type = nil
          @cur_to_type = nil
          @movements_from = []
          @movements_to = []
          @movement_sets = []
          @journal_debits = []
          @journal_credits = []
          @journal_sets = []
          @negative_allowed = false
          @zero_amounts_allowed = true
        end

        def finalize
          unless @movements_from.empty? and @movements_to.empty?
            @movement_sets << {:from => @movements_from, :to => @movements_to}
          end
          @movements_from = []
          @movements_to = []

          unless @journal_debits.empty? && @journal_credits.empty?
            @journal_sets << {:debits => @journal_debits, :credits => @journal_credits}
          end

          @journal_debits = []
          @journal_credits = []
        end

        def also
          #Trigger new set
          @movement_sets << {:from => @movements_from, :to => @movements_to}
          @movements_from = []
          @movements_to = []
        end

        def allow_negative_amounts
          @negative_allowed = true
        end

        def do_not_allow_negative_amounts
          @negative_allowed = false
        end

        def allow_zero_amounts
          @zero_amounts_allowed = true
        end

        def do_not_allow_zero_amounts
          @zero_amounts_allowed = false
        end

        def post_entries(rule, origin)
          transaction_args = origin.transaction_attributes
         # puts "Movement Sets For:", origin
         # p @movement_sets
         # @movement_sets.each do |movement|
         #    puts "------------------------------------------"
         #    movement[:from].each do |from|
         #      puts "#{from[:amount].to_s} from #{from[:ledger_account].friendly_name} (#{from[:ledger_account].is_pea? ? 'PEA' : 'RLS'})"
         #    end
         #    movement[:to].each do |to|
         #      puts "#{to[:amount].to_s} to #{to[:ledger_account].friendly_name} (#{to[:ledger_account].is_pea? ? 'PEA' : 'RLS'})"
         #    end
         # end
         # puts "------------------------------------------"
          return Core.transaction_class.post_movements(rule, origin, @movement_sets, transaction_args) unless @movement_sets.empty?
          return Core.transaction_class.post_journals(rule, origin, @journal_sets, transaction_args) unless @journal_sets.empty?
          # puts "Movements Posted!"
        end

        private

        def debit(ledger, amount, args = {})
          @journal_debits << _debit_or_credit(ledger, amount, args, true)
        end
        alias :dr :debit

        def credit(ledger, amount, args = {})
          @journal_credits << _debit_or_credit(ledger, amount, args, false)
        end
        alias :cr :credit

        def _debit_or_credit(target_ledger, amount, args = {}, is_debit)
          unless @negative_allowed
            raise Exceptions::DSL::NegativeMovementException.new(@rule_name, amount, (is_debit ? 'debit' : 'credit'), target_ledger) if amount < 0
          end

          unless @zero_amounts_allowed
            raise Exceptions::DSL::ZeroAmountMovementException.new(@rule_name, amount, (is_debit ? 'debit' : 'credit'), target_ledger) if amount == 0
          end

          if target_ledger.is_a? Symbol
            target_ledger = Core.ledger_from_symbol target_ledger
          end

          raise Exceptions::DSL::LedgerSecurityException.new(@rule_name, target_ledger) if target_ledger.send(Core.ownership_attribute) != Core.subject

          journal = {
                  :ledger_account => target_ledger,
                  :amount => amount,
                  :args => args
          }
        end

        def move(amount, args)
          if args[:to] and args[:from]
            raise ArgumentError, "move can only have a :from OR a :to"
          end

          target_ledger = args[:to] || args[:from]
          is_to = !args[:to].nil? #Is it movement from, or to?

          unless target_ledger
            raise ArgumentError, "move must have a :from OR a :to"
          end

          unless @negative_allowed
            raise Exceptions::DSL::NegativeMovementException.new(@rule_name, amount, (is_to ? 'to' : 'from'), target_ledger) if amount < 0
          end

          unless @zero_amounts_allowed
            raise Exceptions::DSL::ZeroAmountMovementException.new(@rule_name, amount, (is_to ? 'to' : 'from'), target_ledger) if amount == 0
          end

          if target_ledger.is_a? Symbol
            target_ledger = Core.ledger_from_symbol target_ledger
          end

          raise Exceptions::DSL::LedgerSecurityException.new(@rule_name, target_ledger) if target_ledger.send(Core.ownership_attribute) != Core.subject

          entry_args = args.dup
          entry_args.delete :from
          entry_args.delete :to
          movement = {
                  :ledger_account => target_ledger,
                  :amount => amount,
                  :args => entry_args
          }

          if is_to
            @movements_to << movement
          else
            @movements_from << movement
          end
        end

        #Hook in ghost methods
        def method_missing(id, * args, & block)
          return ghost_method_xyz_of_and_for($1.to_sym, args[0]) if id.to_s =~ /(.*)(_of|_for)$/
          super
        end

        #Ghost method for calling xyz_of, aaa_for on subject object
        def ghost_method_xyz_of_and_for(method, target)
          unless target.respond_to?(method)
            raise Exceptions::DSL::MethodException.new(target, method)
          end
          target.send method
        end

      end
    end
  end
end
